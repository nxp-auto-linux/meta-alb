From 4763d8daae6ea8b62edb90d2ff6e878e7db7b807 Mon Sep 17 00:00:00 2001
From: Heinz Wrobel <Heinz.Wrobel@nxp.com>
Date: Sun, 2 Apr 2023 14:13:59 +0200
Subject: [PATCH] u-boot-qoriq: Support of LX2160A BlueBox3

Signed-off-by: Heinz Wrobel <Heinz.Wrobel@nxp.com>
---
 arch/arm/Kconfig                              |  15 +
 arch/arm/cpu/armv8/Kconfig                    |   1 +
 arch/arm/dts/fsl-lx2160a-bluebox3.dts         | 660 ++++++++++++++++
 board/freescale/lx2160abluebox3/Kconfig       |  17 +
 board/freescale/lx2160abluebox3/MAINTAINERS   |  13 +
 board/freescale/lx2160abluebox3/Makefile      |   8 +
 board/freescale/lx2160abluebox3/README        |  81 ++
 board/freescale/lx2160abluebox3/ddr.c         |  21 +
 .../lx2160abluebox3/eth_lx2160abluebox3.c     | 113 +++
 .../lx2160abluebox3/lx2160abluebox3.c         | 728 ++++++++++++++++++
 .../lx2160abluebox3_tfa_SECURE_BOOT_defconfig | 119 +++
 configs/lx2160abluebox3_tfa_defconfig         | 116 +++
 include/configs/lx2160abluebox3.h             | 123 +++
 13 files changed, 2015 insertions(+)
 create mode 100644 arch/arm/dts/fsl-lx2160a-bluebox3.dts
 create mode 100644 board/freescale/lx2160abluebox3/Kconfig
 create mode 100644 board/freescale/lx2160abluebox3/MAINTAINERS
 create mode 100644 board/freescale/lx2160abluebox3/Makefile
 create mode 100644 board/freescale/lx2160abluebox3/README
 create mode 100644 board/freescale/lx2160abluebox3/ddr.c
 create mode 100644 board/freescale/lx2160abluebox3/eth_lx2160abluebox3.c
 create mode 100644 board/freescale/lx2160abluebox3/lx2160abluebox3.c
 create mode 100644 configs/lx2160abluebox3_tfa_SECURE_BOOT_defconfig
 create mode 100644 configs/lx2160abluebox3_tfa_defconfig
 create mode 100644 include/configs/lx2160abluebox3.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index a5d94cdb46..3425a5dbf7 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1423,6 +1423,20 @@ config TARGET_LX2162AQDS
 	  Support for NXP LX2162AQDS platform.
 	  The lx2162aqds support is based on LX2160A Layerscape Architecture processor.
 
+config TARGET_LX2160ABLUEBOX3
+	bool "Support lx2160abluebox3"
+	select ARCH_LX2160A
+	select ARM64
+	select ARMV8_MULTIENTRY
+	select ARCH_SUPPORT_TFABOOT
+	select BOARD_LATE_INIT
+	select GPIO_EXTRA_HEADER
+	help
+	  Support for NXP BlueBox3 platform.
+	  The BlueBox 3 Reference design is a high-performance development
+	  platform that supports the QorIQ LX2160A Layerscape Architecture
+	  Processor and the S32G274A Automotive Processor
+
 config TARGET_HIKEY
 	bool "Support HiKey 96boards Consumer Edition Platform"
 	select ARM64
@@ -2258,6 +2272,7 @@ source "board/freescale/ls1012aqds/Kconfig"
 source "board/freescale/ls1012ardb/Kconfig"
 source "board/freescale/ls1012afrdm/Kconfig"
 source "board/freescale/lx2160a/Kconfig"
+source "board/freescale/lx2160abluebox3/Kconfig"
 source "board/grinn/chiliboard/Kconfig"
 source "board/hisilicon/hikey/Kconfig"
 source "board/hisilicon/hikey960/Kconfig"
diff --git a/arch/arm/cpu/armv8/Kconfig b/arch/arm/cpu/armv8/Kconfig
index 82c4c61507..c3f8a3d561 100644
--- a/arch/arm/cpu/armv8/Kconfig
+++ b/arch/arm/cpu/armv8/Kconfig
@@ -116,6 +116,7 @@ config PSCI_RESET
 		   !TARGET_LS1046AFRWY && \
 		   !TARGET_LS2081ARDB && !TARGET_LX2160ARDB && \
 		   !TARGET_LX2160AQDS && !TARGET_LX2162AQDS && \
+		   !TARGET_LX2160ABLUEBOX3 && \
 		   !ARCH_UNIPHIER
 	help
 	  Most armv8 systems have PSCI support enabled in EL3, either through
diff --git a/arch/arm/dts/fsl-lx2160a-bluebox3.dts b/arch/arm/dts/fsl-lx2160a-bluebox3.dts
new file mode 100644
index 0000000000..0f2ba27c7a
--- /dev/null
+++ b/arch/arm/dts/fsl-lx2160a-bluebox3.dts
@@ -0,0 +1,660 @@
+// SPDX-License-Identifier: GPL-2.0+ OR X11
+/*
+ * NXP LX2160A BlueBox3 device tree source
+ *
+ * Copyright 2020-2021, 2023 NXP
+ *
+ */
+
+/dts-v1/;
+
+#include "fsl-lx2160a.dtsi"
+
+/ {
+	model = "NXP Layerscape LX2160A BlueBox3 Board";
+	compatible = "fsl,lx2160ardb", "fsl,lx2160a";
+	aliases {
+		spi0 = &fspi;
+	};
+
+	sb_3v3: regulator-sb3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "MC34717-3.3VSB";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+&dpmac5 {
+	status = "okay";
+	phy-handle = <&aquantia_phy2>;
+	phy-connection-type = "usxgmii";
+};
+
+&dpmac6 {
+	status = "okay";
+	phy-handle = <&aquantia_phy1>;
+	phy-connection-type = "usxgmii";
+};
+
+&dpmac9 {
+	status = "okay";
+	phy-handle = <&aquantia_phy4>;
+	phy-connection-type = "usxgmii";
+};
+
+&dpmac10 {
+	status = "okay";
+	phy-handle = <&aquantia_phy3>;
+	phy-connection-type = "usxgmii";
+};
+
+&dpmac17 {
+	status = "okay";
+	phy-handle = <&sw1_mii3_phy>;
+	phy-connection-type = "rgmii-id";
+};
+
+&dpmac18 {
+	status = "okay";
+	phy-handle = <&sw2_mii3_phy>;
+	phy-connection-type = "rgmii-id";
+};
+
+&emdio1 {
+	status = "okay";
+	aquantia_phy1: ethernet-phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <0x0>;
+	};
+
+	aquantia_phy2: ethernet-phy@8 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <0x8>;
+	};
+
+	sw1_mii3_phy: ethernet-phy@1 {
+		/* AR8035 */
+		compatible = "ethernet-phy-id004d.d072";
+		reg = <0x5>;
+	};
+
+	sw2_mii3_phy: ethernet-phy@2 {
+		/* AR8035 */
+		compatible = "ethernet-phy-id004d.d072";
+		reg = <0x6>;
+	};
+};
+
+&emdio2 {
+	status = "okay";
+	aquantia_phy3: ethernet-phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <0x0>;
+	};
+
+	aquantia_phy4: ethernet-phy@8 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <0x8>;
+	};
+};
+
+&esdhc0 {
+	status = "okay";
+};
+
+&esdhc1 {
+	status = "okay";
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	bus-width = <8>;
+};
+
+&fspi {
+	status = "okay";
+
+	mt35xu512aba0: flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <50000000>;
+		reg = <0>;
+		spi-rx-bus-width = <8>;
+		spi-tx-bus-width = <1>;
+	};
+
+	mt35xu512aba1: flash@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <50000000>;
+		reg = <1>;
+		spi-rx-bus-width = <8>;
+		spi-tx-bus-width = <1>;
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+
+	pca9547@77 {
+		compatible = "nxp,pca9547";
+		reg = <0x77>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		i2c@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x1>;
+
+			fan-controller@4c {
+				compatible = "smsc,emc2305";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x4c>;
+
+				fan6: fan@0 {
+					reg = <0>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan7: fan@1 {
+					reg = <1>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan8: fan@2 {
+					reg = <2>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan9: fan@3 {
+					reg = <3>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan10: fan@4 {
+					reg = <4>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+			};
+
+			fan-controller@4d {
+				compatible = "smsc,emc2305";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x4d>;
+
+				fan1: fan@0 {
+					reg = <0>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan2: fan@1 {
+					reg = <1>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan3: fan@2 {
+					reg = <2>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan4: fan@3 {
+					reg = <3>;
+					#cooling-cells = <2>;
+					cooling-levels = <0 25 128 255>;
+				};
+
+				fan5: fan@4 {
+					reg = <4>;
+					#cooling-cells = <2>;
+					// ducy cycle = (cooling-lveles[index] / 255) * 100%
+					// (0 / 255) * 100% = 0%
+					// (25 / 255) * 100% = 9.8%
+					// (128 / 255) * 100% = 50%
+					// (255 / 255) * 100% = 100%
+					cooling-levels = <0 25 128 255>;
+				};
+			};
+		};
+
+		i2c@2 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x2>;
+
+			power-monitor@40 {
+				compatible = "ti,ina220";
+				reg = <0x40>;
+				shunt-resistor = <500>;
+			};
+		};
+
+		i2c@3 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x3>;
+
+			temp2: temperature-sensor@48 {
+				compatible = "nxp,sa56004";
+				reg = <0x48>;
+				vcc-supply = <&sb_3v3>;
+				#thermal-sensor-cells = <1>;
+			};
+
+			temp1: temperature-sensor@4c {
+				compatible = "nxp,sa56004";
+				reg = <0x4c>;
+				vcc-supply = <&sb_3v3>;
+				#thermal-sensor-cells = <1>;
+			};
+		};
+
+		i2c@4 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x4>;
+
+			rtc@51 {
+				compatible = "pcf2127-rtc";
+				reg = <0x51>;
+			};
+		};
+
+		i2c@7 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x7>;
+
+			i2c-mux@75 {
+				compatible = "nxp,pca9547";
+				reg = <0x75>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				i2c@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+
+					spi_bridge: spi@28 {
+						compatible = "nxp,sc18is602b";
+						reg = <0x28>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+
+	i2c-mux@77 {
+		compatible = "nxp,pca9846";
+		reg = <0x77>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		i2c@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x1>;
+			i2c-mux@70 {
+				/* The i2c multiplexer and temp sensors are on T6 riser card */
+				compatible = "nxp,pca9548";
+				reg = <0x70>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				i2c@6 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x6>;
+					q12: temperature-sensor@4c {
+						compatible = "nxp,sa56004";
+						reg = <0x4c>;
+						vcc-supply = <&sb_3v3>;
+						#thermal-sensor-cells = <1>;
+					};
+				};
+				i2c@7 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x7>;
+					q11: temperature-sensor@4c {
+						compatible = "nxp,sa56004";
+						reg = <0x4c>;
+						vcc-supply = <&sb_3v3>;
+						#thermal-sensor-cells = <1>;
+					};
+					q13: temperature-sensor@48 {
+						compatible = "nxp,sa56004";
+						reg = <0x48>;
+						vcc-supply = <&sb_3v3>;
+						#thermal-sensor-cells = <1>;
+					};
+					q14: temperature-sensor@4a {
+						compatible = "nxp,sa56004";
+						reg = <0x4a>;
+						vcc-supply = <&sb_3v3>;
+						#thermal-sensor-cells = <1>;
+					};
+				};
+			};
+		};
+
+	};
+};
+
+&spi_bridge {
+	/* SW1 */
+	ethernet-switch@0 {
+		compatible = "nxp,sja1110a";
+		reg = <0>;
+		spi-max-frequency = <4000000>;
+		spi-cpol;
+		dsa,member = <0 0>;
+
+		ethernet-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* Microcontroller port */
+			port@0 {
+				reg = <0>;
+				status = "disabled";
+			};
+
+			/* SW1_P1 */
+			port@1 {
+				reg = <1>;
+				label = "con_2x20";
+				phy-mode = "sgmii";
+
+				fixed-link {
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				ethernet = <&dpmac17>;
+				phy-mode = "rgmii-id";
+
+				fixed-link {
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+
+			port@3 {
+				reg = <3>;
+				label = "1ge_p1";
+				phy-mode = "rgmii-id";
+				phy-handle = <&sw1_mii3_phy>;
+			};
+
+			port@4 {
+				reg = <4>;
+				label = "to_sw2";
+				phy-mode = "sgmii";
+
+				fixed-link {
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+
+			port@5 {
+				reg = <5>;
+				label = "trx1";
+				phy-mode = "internal";
+				phy-handle = <&sw1_port5_base_t1_phy>;
+			};
+
+			port@6 {
+				reg = <6>;
+				label = "trx2";
+				phy-mode = "internal";
+				phy-handle = <&sw1_port6_base_t1_phy>;
+			};
+
+			port@7 {
+				reg = <7>;
+				label = "trx3";
+				phy-mode = "internal";
+				phy-handle = <&sw1_port7_base_t1_phy>;
+			};
+
+			port@8 {
+				reg = <8>;
+				label = "trx4";
+				phy-mode = "internal";
+				phy-handle = <&sw1_port8_base_t1_phy>;
+			};
+
+			port@9 {
+				reg = <9>;
+				label = "trx5";
+				phy-mode = "internal";
+				phy-handle = <&sw1_port9_base_t1_phy>;
+			};
+
+			port@a {
+				reg = <10>;
+				label = "trx6";
+				phy-mode = "internal";
+				phy-handle = <&sw1_port10_base_t1_phy>;
+			};
+		};
+
+		mdios {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mdio@0 {
+				reg = <0>;
+				compatible = "nxp,sja1110-base-t1-mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				sw1_port5_base_t1_phy: ethernet-phy@1 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x1>;
+				};
+
+				sw1_port6_base_t1_phy: ethernet-phy@2 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x2>;
+				};
+
+				sw1_port7_base_t1_phy: ethernet-phy@3 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x3>;
+				};
+
+				sw1_port8_base_t1_phy: ethernet-phy@4 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x4>;
+				};
+
+				sw1_port9_base_t1_phy: ethernet-phy@5 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x5>;
+				};
+
+				sw1_port10_base_t1_phy: ethernet-phy@6 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x6>;
+				};
+			};
+		};
+	};
+
+	/* SW2 */
+	ethernet-switch@2 {
+		compatible = "nxp,sja1110a";
+		reg = <2>;
+		spi-max-frequency = <4000000>;
+		spi-cpol;
+		dsa,member = <1 1>;
+
+		ethernet-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* Microcontroller port */
+			port@0 {
+				reg = <0>;
+				status = "disabled";
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "to_sw1";
+				phy-mode = "sgmii";
+
+				fixed-link {
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				ethernet = <&dpmac18>;
+				phy-mode = "rgmii-id";
+
+				fixed-link {
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+
+			port@3 {
+				reg = <3>;
+				label = "1ge_p2";
+				phy-mode = "rgmii-id";
+				phy-handle = <&sw2_mii3_phy>;
+			};
+
+			port@4 {
+				reg = <4>;
+				label = "to_sw3";
+				phy-mode = "2500base-x";
+
+				fixed-link {
+					speed = <2500>;
+					full-duplex;
+				};
+			};
+
+			port@5 {
+				reg = <5>;
+				label = "trx7";
+				phy-mode = "internal";
+				phy-handle = <&sw2_port5_base_t1_phy>;
+			};
+
+			port@6 {
+				reg = <6>;
+				label = "trx8";
+				phy-mode = "internal";
+				phy-handle = <&sw2_port6_base_t1_phy>;
+			};
+
+			port@7 {
+				reg = <7>;
+				label = "trx9";
+				phy-mode = "internal";
+				phy-handle = <&sw2_port7_base_t1_phy>;
+			};
+
+			port@8 {
+				reg = <8>;
+				label = "trx10";
+				phy-mode = "internal";
+				phy-handle = <&sw2_port8_base_t1_phy>;
+			};
+
+			port@9 {
+				reg = <9>;
+				label = "trx11";
+				phy-mode = "internal";
+				phy-handle = <&sw2_port9_base_t1_phy>;
+			};
+
+			port@a {
+				reg = <10>;
+				label = "trx12";
+				phy-mode = "internal";
+				phy-handle = <&sw2_port10_base_t1_phy>;
+			};
+		};
+
+		mdios {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mdio@0 {
+				reg = <0>;
+				compatible = "nxp,sja1110-base-t1-mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				sw2_port5_base_t1_phy: ethernet-phy@1 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x1>;
+				};
+
+				sw2_port6_base_t1_phy: ethernet-phy@2 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x2>;
+				};
+
+				sw2_port7_base_t1_phy: ethernet-phy@3 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x3>;
+				};
+
+				sw2_port8_base_t1_phy: ethernet-phy@4 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x4>;
+				};
+
+				sw2_port9_base_t1_phy: ethernet-phy@5 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x5>;
+				};
+
+				sw2_port10_base_t1_phy: ethernet-phy@6 {
+					compatible = "ethernet-phy-ieee802.3-c45";
+					reg = <0x6>;
+				};
+			};
+		};
+	};
+};
+
+&usb0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
diff --git a/board/freescale/lx2160abluebox3/Kconfig b/board/freescale/lx2160abluebox3/Kconfig
new file mode 100644
index 0000000000..9caddf4129
--- /dev/null
+++ b/board/freescale/lx2160abluebox3/Kconfig
@@ -0,0 +1,17 @@
+
+if TARGET_LX2160ABLUEBOX3
+
+config SYS_BOARD
+        default "lx2160abluebox3"
+
+config SYS_VENDOR
+        default "freescale"
+
+config SYS_SOC
+        default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+        default "lx2160abluebox3"
+
+source "board/freescale/common/Kconfig"
+endif
diff --git a/board/freescale/lx2160abluebox3/MAINTAINERS b/board/freescale/lx2160abluebox3/MAINTAINERS
new file mode 100644
index 0000000000..608edf8c90
--- /dev/null
+++ b/board/freescale/lx2160abluebox3/MAINTAINERS
@@ -0,0 +1,13 @@
+LX2160ABLUEBOX3 BOARD
+M:	Vabhav Sharma <vabhav.sharma@nxp.com>
+S:	Maintained
+F:	board/freescale/lx2160abluebox3/
+F:	board/freescale/lx2160abluebox3/lx2160abluebox3.c
+F:	include/configs/lx2160abluebox3.h
+F:	configs/lx2160abluebox3_tfa_defconfig
+F:	arch/arm/dts/fsl-lx2160a-bluebox3.dts
+
+LX2160ABLUEBOX3_SECURE_BOOT BOARD
+M:	Udit Agarwal <udit.agarwal@nxp.com>
+S:	Maintained
+F:	configs/lx2160abluebox3_tfa_SECURE_BOOT_defconfig
diff --git a/board/freescale/lx2160abluebox3/Makefile b/board/freescale/lx2160abluebox3/Makefile
new file mode 100644
index 0000000000..2d2d804ca7
--- /dev/null
+++ b/board/freescale/lx2160abluebox3/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright 2020 Freescale Semiconductor
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += lx2160abluebox3.o eth_lx2160abluebox3.o
+obj-y += ddr.o
diff --git a/board/freescale/lx2160abluebox3/README b/board/freescale/lx2160abluebox3/README
new file mode 100644
index 0000000000..a1bd8276c7
--- /dev/null
+++ b/board/freescale/lx2160abluebox3/README
@@ -0,0 +1,81 @@
+Overview
+--------
+The BlueBox3 Reference design is a high-performance computing,
+evaluation, and development platform that supports the QorIQ LX2160A
+Layerscape Architecture Processor and the S32G274A Automotive Processor
+
+LX2160A SoC Overview
+--------------------
+For details, please refer arch/arm/cpu/armv8/fsl-layerscape/doc/README.soc
+
+LX2160BLUEBOX3 board Overview
+-----------------------------
+DDR Memory
+	Two ports of 72-bits (8-bits ECC) DDR4.
+	Each port supports four chip-selects and two DIMM
+	connectors. Data rate upto 3.2 GT/s.
+
+SERDES ports
+	Thress serdes controllers (24 lanes)
+
+	Serdes1:
+	Supports four USXGMII to RJ45 connector (MAC 5, 6, 9, 10) and
+	each connected through Aquantia AQR113 PHY
+
+	Support PCIe x2 Gen2 connectivity to M.2 NVMe SSD
+
+	Support PCIe x2 Gen2 connectivity to S32G SoM Interfaces
+
+	Serdes2: Supports one PCIe x8 (Gen1/2/3) connector
+
+	Serdes3: Supports one PCIe x8 (Gen1/2/3) connector
+
+eSDHC
+	eSDHC1: Supports a SD connector for connecting SD cards
+	eSDHC2: Supports 128GB eMMC memory MICRON MTFC128GAJAECE
+
+Octal SPI (XSPI)
+	Supports two 64 MB onbpard octal SPI flash memories MT35XU512ABA1G12
+
+I2C	All system devices on I2C1 multiplexed using PCA9547 multiplexer
+	Serial Ports and PCIe M.2, PCIe Slot 1, PCIe slot 2 on I2C6 using
+	PCA9546 multiplexer
+
+USB 3.0
+	One high speed USB 3.0 port, configured as Host with Type-A connector
+
+Serial Ports	Two UART ports, Two CAN interfaces
+Ethernet	Two RGMII interfaces
+Debug		ARM JTAG support
+
+Booting Options
+---------------
+a) Flexspi boot
+b) SD boot
+c) eMMC boot
+
+Memory map for Flexspi flash
+----------------------------
+Image							Flash Offset
+bl2_flexspi_nor.pbl (RCW+PBI+bl2.pbl)			0x00000000
+fip.bin (bl31 + bl33(u-boot) +
+	 header for Secure-boot(secure-boot only))	0x00100000
+Boot firmware Environment				0x00500000
+DDR PHY Firmware (fip_ddr_all.bin)			0x00800000
+DPAA2 MC Firmware					0x00A00000
+DPAA2 DPL						0x00D00000
+DPAA2 DPC						0x00E00000
+Kernel.itb						0x01000000
+
+Memory map for sd/eMMC card
+----------------------------
+Image							SD/eMMC card Offset
+bl2_sd.pbl (RCW+PBI+bl2.pbl)				0x00008
+fip.bin (bl31 + bl33(u-boot) +
+	 header for Secure-boot(secure-boot only))	0x00800
+Boot firmware Environment				0x02800
+DDR PHY Firmware (fip_ddr_all.bin)			0x04000
+DPAA2 MC Firmware					0x05000
+DPAA2 DPL						0x06800
+DPAA2 DPC						0x07000
+Kernel.itb						0x08000
diff --git a/board/freescale/lx2160abluebox3/ddr.c b/board/freescale/lx2160abluebox3/ddr.c
new file mode 100644
index 0000000000..7ba0f27bd6
--- /dev/null
+++ b/board/freescale/lx2160abluebox3/ddr.c
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020, 2023 NXP
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int fsl_initdram(void)
+{
+	gd->ram_size = tfa_get_dram_size();
+
+	if (!gd->ram_size)
+		gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+}
diff --git a/board/freescale/lx2160abluebox3/eth_lx2160abluebox3.c b/board/freescale/lx2160abluebox3/eth_lx2160abluebox3.c
new file mode 100644
index 0000000000..70efa69041
--- /dev/null
+++ b/board/freescale/lx2160abluebox3/eth_lx2160abluebox3.c
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020 NXP
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <fm_eth.h>
+#include <asm/io.h>
+#include <exports.h>
+#include <asm/arch/fsl_serdes.h>
+#include <fsl-mc/fsl_mc.h>
+#include <fsl-mc/ldpaa_wriop.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_eth_init(struct bd_info *bis)
+{
+#if defined(CONFIG_FSL_MC_ENET)
+	struct memac_mdio_info mdio_info;
+	struct memac_mdio_controller *reg;
+	int i;
+	struct mii_dev *dev;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 srds_s1;
+
+	srds_s1 = in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+
+	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO1;
+	mdio_info.regs = reg;
+	mdio_info.name = DEFAULT_WRIOP_MDIO1_NAME;
+
+	/* Register the EMI 1 */
+	fm_memac_mdio_init(bis, &mdio_info);
+
+	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO2;
+	mdio_info.regs = reg;
+	mdio_info.name = DEFAULT_WRIOP_MDIO2_NAME;
+
+	/* Register the EMI 2 */
+	fm_memac_mdio_init(bis, &mdio_info);
+
+	/* BlueBox3 uses custom RCW and SerDes protocol 31, based on 11 */
+	if (srds_s1 != 31) {
+		printf("SerDes1 protocol 0x%x is not supported by LX2160A-BlueBox3\n",
+		       srds_s1);
+		goto next;
+	}
+
+	/* USXGMII setup */
+	wriop_init_dpmac_enet_if(WRIOP1_DPMAC5, PHY_INTERFACE_MODE_USXGMII);
+	wriop_init_dpmac_enet_if(WRIOP1_DPMAC6, PHY_INTERFACE_MODE_USXGMII);
+	wriop_init_dpmac_enet_if(WRIOP1_DPMAC9, PHY_INTERFACE_MODE_USXGMII);
+	wriop_init_dpmac_enet_if(WRIOP1_DPMAC10, PHY_INTERFACE_MODE_USXGMII);
+	wriop_set_phy_address(WRIOP1_DPMAC5, 0, AQR113_PHY_ADDR1);
+	wriop_set_phy_address(WRIOP1_DPMAC6, 0, AQR113_PHY_ADDR2);
+	wriop_set_phy_address(WRIOP1_DPMAC9, 0, AQR113_PHY_ADDR3);
+	wriop_set_phy_address(WRIOP1_DPMAC10, 0, AQR113_PHY_ADDR4);
+
+
+	/* assign DPMAC and corresponding PHYs to MDIO busses */
+	for (i = WRIOP1_DPMAC5; i <= WRIOP1_DPMAC6; i++) {
+		dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO1_NAME);
+		wriop_set_mdio(i, dev);
+	}
+
+	for (i = WRIOP1_DPMAC9; i <= WRIOP1_DPMAC10; i++) {
+		dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO2_NAME);
+		wriop_set_mdio(i, dev);
+	}
+
+next:
+	cpu_eth_init(bis);
+#endif /* CONFIG_FSL_MC_ENET */
+
+#ifdef CONFIG_PHY_AQUANTIA
+	/*
+	 * Export functions to be used by AQ firmware
+	 * upload application
+	 */
+	gd->jt->strcpy = strcpy;
+	gd->jt->mdelay = mdelay;
+	gd->jt->mdio_get_current_dev = mdio_get_current_dev;
+	gd->jt->phy_find_by_mask = phy_find_by_mask;
+	gd->jt->mdio_phydev_for_ethname = mdio_phydev_for_ethname;
+	gd->jt->miiphy_set_current_dev = miiphy_set_current_dev;
+#endif
+	return pci_eth_init(bis);
+}
+
+#if defined(CONFIG_RESET_PHY_R)
+void reset_phy(void)
+{
+#if defined(CONFIG_FSL_MC_ENET)
+	mc_env_boot();
+#endif
+}
+#endif /* CONFIG_RESET_PHY_R */
+
+int fdt_fixup_board_phy(void *fdt)
+{
+	//TO DO
+	return 0;
+}
diff --git a/board/freescale/lx2160abluebox3/lx2160abluebox3.c b/board/freescale/lx2160abluebox3/lx2160abluebox3.c
new file mode 100644
index 0000000000..30331e5753
--- /dev/null
+++ b/board/freescale/lx2160abluebox3/lx2160abluebox3.c
@@ -0,0 +1,728 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020 NXP
+ */
+
+#include <common.h>
+#include <clock_legacy.h>
+#include <dm.h>
+#include <init.h>
+#include <asm/global_data.h>
+#include <dm/platform_data/serial_pl01x.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <fsl_ddr.h>
+#include <fsl_sec.h>
+#include <asm/io.h>
+#include <fdt_support.h>
+#include <linux/libfdt.h>
+#include <fsl-mc/fsl_mc.h>
+#include <env_internal.h>
+#include <efi_loader.h>
+#include <asm/arch/mmu.h>
+#include <hwconfig.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/config.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/soc.h>
+#include "../common/i2c_mux.h"
+
+#include "../common/qixis.h"
+#include "../common/vid.h"
+#include <fsl_immap.h>
+#include <asm/arch-fsl-layerscape/fsl_icid.h>
+#include <asm/gic-v3.h>
+#include <cpu_func.h>
+
+#ifdef CONFIG_EMC2305
+#include "../common/emc2305.h"
+#endif
+
+#define GIC_LPI_SIZE                             0x200000
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct pl01x_serial_plat serial0 = {
+#if CONFIG_CONS_INDEX == 0
+	.base = CONFIG_SYS_SERIAL0,
+#elif CONFIG_CONS_INDEX == 1
+	.base = CONFIG_SYS_SERIAL1,
+#else
+#error "Unsupported console index value."
+#endif
+	.type = TYPE_PL011,
+};
+
+U_BOOT_DRVINFO(nxp_serial0) = {
+	.name = "serial_pl01x",
+	.plat = &serial0,
+};
+
+static struct pl01x_serial_plat serial1 = {
+	.base = CONFIG_SYS_SERIAL1,
+	.type = TYPE_PL011,
+};
+
+U_BOOT_DRVINFO(nxp_serial1) = {
+	.name = "serial_pl01x",
+	.plat = &serial1,
+};
+
+static int select_i2c_ch(int busnum, int muxaddr, u8 ch)
+{
+	int ret;
+
+	struct udevice *dev;
+
+	ret = i2c_get_chip_for_busnum(busnum, muxaddr, 1, &dev);
+	if (!ret)
+		ret = dm_i2c_write(dev, 0, &ch, 1);
+
+	return ret;
+}
+
+static int select_i2c_ch_t6slot6ctrl(void)
+{
+	int ret;
+
+	ret = select_i2c_ch(I2C_PCIE_BUS_NUM, I2C_PCIE_MUX_PCA9846_ADDR_PRI, I2C_PCIE_MUX_CH_PCIE_MB2);
+	if (!ret)
+		ret = select_i2c_ch(I2C_PCIE_BUS_NUM, I2C_T6_PCA9546_ADDR, I2C_T6_MUX_CH_SLOT6CTRL);
+
+	return ret;
+}
+
+static void configure_t6slot6(void)
+{
+	char buf[HWCONFIG_BUFFER_SIZE];
+	int ret;
+	int equalizerschanged = 0;
+	int lanes = -1;
+	struct udevice *dev_pcal6408;
+	struct udevice *dev_ptn3944_0;
+	struct udevice *dev_ptn3944_1;
+	struct udevice *dev_ptn3944_2;
+	struct udevice *dev_ptn3944_3;
+	u8 pins, eq_is0to3, eq_is4to7, eq_should;
+
+	/* We assume autoconfig without hwconfig specified */
+	lanes = -1;
+
+	/*
+	 * Extract hwconfig from environment since we have not properly setup
+	 * the environment but need it for T6 params
+	 */
+	if (env_get_f("hwconfig", buf, sizeof(buf)) < 0)
+		buf[0] = '\0';
+
+	if (hwconfig_sub_f("pcie", "t6slot6", buf)) {
+		if (hwconfig_subarg_cmp_f("pcie", "t6slot6", "off", buf))
+			lanes = 0;
+		else if (hwconfig_subarg_cmp_f("pcie", "t6slot6", "auto", buf))
+			lanes = 256;
+		else if (hwconfig_subarg_cmp_f("pcie", "t6slot6", "x1", buf))
+			lanes = 1;
+		else if (hwconfig_subarg_cmp_f("pcie", "t6slot6", "x2", buf))
+			lanes = 2;
+		else if (hwconfig_subarg_cmp_f("pcie", "t6slot6", "x4", buf))
+			lanes = 4;
+		else if (hwconfig_subarg_cmp_f("pcie", "t6slot6", "x8", buf))
+			lanes = 8;
+		else if (hwconfig_subarg_cmp_f("pcie", "t6slot6", "x16", buf))
+			lanes = 16;
+	}
+
+	debug("T6slot6: %d lanes hwconfig '%s'\n", lanes, buf);
+
+	/*
+	 * Fail silently and gracefully if there is no T6 riser only
+	 * if we do not request a config through the environment!
+	 * We may run a system with T2 or without riser.
+	 */
+	if (select_i2c_ch_t6slot6ctrl()) {
+		if (lanes >= 0)
+			puts("T6 riser not detected, hwconfig pcie:t6slot6 setting will be ignored!\n");
+		return;
+	}
+
+	/* No specific T6slot6 setting means auto config! */
+	if (lanes < 0 || lanes >= 256) {
+		if (i2c_get_chip_for_busnum(I2C_PCIE_BUS_NUM, I2C_T6_PCAL6408_ADDR, 1, &dev_pcal6408)) {
+			puts("T6 slot6: Cannot find PCAL6408!\n");
+			return;
+		}
+
+		/* Determine the number of plugged lanes by presence detect */
+		ret = dm_i2c_read(dev_pcal6408, I2C_T6_PCAL6408_INPUT_PORT, (void *)&pins, 1);
+		if (ret) {
+			puts("T6 slot6: Cannot read PCAL6408!\n");
+			return;
+		}
+
+		pins &= I2C_T6_PCAL6408_PRESENCE_DETECT_MASK;
+		pins ^= I2C_T6_PCAL6408_PRESENCE_DETECT_MASK;
+
+		lanes = (pins & 0x8) ? 16 :
+			(pins & 0x4) ? 8 :
+			(pins & 0x2) ? 4 :
+			(pins & 0x1) ? 1 : 0;
+
+		/*
+		 * We don't waste time if no card is plugged in.
+		 * This should only happen for auto config!
+		 */
+		if (!lanes)
+			return;
+
+		printf("T6 slot6: Detected card width of %d lanes\n", lanes);
+	}
+
+	if (i2c_get_chip_for_busnum(I2C_PCIE_BUS_NUM, I2C_T6_PTN3944_BASE_ADDR + 0, 1, &dev_ptn3944_0) ||
+	    i2c_get_chip_for_busnum(I2C_PCIE_BUS_NUM, I2C_T6_PTN3944_BASE_ADDR + 1, 1, &dev_ptn3944_1) ||
+	    i2c_get_chip_for_busnum(I2C_PCIE_BUS_NUM, I2C_T6_PTN3944_BASE_ADDR + 2, 1, &dev_ptn3944_2) ||
+	    i2c_get_chip_for_busnum(I2C_PCIE_BUS_NUM, I2C_T6_PTN3944_BASE_ADDR + 3, 1, &dev_ptn3944_3)) {
+		puts("T6 slot6: Cannot find equalizers on T6 riser I2C!\n");
+		return;
+	}
+
+	/* Check and update the equalizers */
+	ret = dm_i2c_read(dev_ptn3944_0, PTN3944_LINK_CTRL_STATUS, (void *)&eq_is0to3, 1);
+	ret |= dm_i2c_read(dev_ptn3944_2, PTN3944_LINK_CTRL_STATUS, (void *)&eq_is4to7, 1);
+	if (ret) {
+		printf("T6 slot6: Cannot read equalizer settings on T6 riser I2C\n");
+		return;
+	}
+	debug("eq_is0to3: %02x\n", eq_is0to3);
+	debug("eq_is4to7: %02x\n", eq_is4to7);
+
+	/* First check lanes 0-3, then 4-7 */
+	eq_should = (lanes >= 4) ? PTN3944_LCS_4CHANNELS :
+		    (lanes >= 2) ? PTN3944_LCS_2CHANNELS :
+		    (lanes >= 1) ? PTN3944_LCS_1CHANNELS :
+		    PTN3944_LCS_0CHANNELS;
+	if ((eq_is0to3 & PTN3944_LCS_CHANNEL_MASK) != eq_should) {
+		ret |= dm_i2c_write(dev_ptn3944_0, PTN3944_LINK_CTRL_STATUS, (void *)&eq_should, 1);
+		ret |= dm_i2c_write(dev_ptn3944_1, PTN3944_LINK_CTRL_STATUS, (void *)&eq_should, 1);
+		equalizerschanged = 1;
+	}
+
+	eq_should = (lanes >= 8) ? PTN3944_LCS_4CHANNELS :
+		    PTN3944_LCS_0CHANNELS;
+	if ((eq_is4to7 & PTN3944_LCS_CHANNEL_MASK) != eq_should) {
+		ret |= dm_i2c_write(dev_ptn3944_2, PTN3944_LINK_CTRL_STATUS, (void *)&eq_should, 1);
+		ret |= dm_i2c_write(dev_ptn3944_3, PTN3944_LINK_CTRL_STATUS, (void *)&eq_should, 1);
+		equalizerschanged = 1;
+	}
+
+	if (ret) {
+		printf("T6 slot6: Updating the equalizer settings failed\n");
+		return;
+	}
+
+	/*
+	 * Unfortunately we have to reboot after the equalizer change
+	 * because the PCIe controller can get stuck in compliance
+	 * pattern handling and we do not have a spec compliant way to
+	 * reset just the LTSSM properly. If we can come up with a way
+	 * to just reset the LTSSM, it would be much nicer.
+	 */
+	if (equalizerschanged) {
+		enum boot_src src = get_boot_src();
+
+		printf("T6 slot6: Reconfigured to %d lanes, rebooting ...\n", lanes);
+
+		/* Trying hard to preserve the boot source */
+		if (src == BOOT_SOURCE_SD_MMC) {
+			run_command("qixis_reset sd", 0);
+		} else if (src == BOOT_SOURCE_SD_MMC2) {
+			run_command("qixis_reset emmc", 0);
+		} else {
+			u8 sw;
+
+			sw = QIXIS_READ(brdcfg[0]);
+			sw = (sw >> QIXIS_XMAP_SHIFT) & QIXIS_XMAP_MASK;
+			switch (sw) {
+			case 0:
+				run_command("qixis_reset qspi", 0);
+				break;
+			case 1:
+				run_command("qixis_reset altbank", 0);
+				break;
+			default:
+				/* generic reset for any other combination */
+				run_command("reset", 0);
+				break;
+			}
+		}
+		/*
+		 * It takes a little while until the Qixis reset kicks
+		 * in. We want to wait until it does
+		 */
+		while (1)
+			/* do nothing */;
+	}
+}
+
+static void uart_get_clock(void)
+{
+	serial0.clock = get_serial_clock();
+	serial1.clock = get_serial_clock();
+}
+
+int board_early_init_f(void)
+{
+#if defined(CONFIG_SYS_I2C_EARLY_INIT) && defined(CONFIG_SPL_BUILD)
+	i2c_early_init_f();
+#endif
+	/* get required clock for UART IP */
+	uart_get_clock();
+
+#ifdef CONFIG_EMC2305
+	select_i2c_ch_pca9547(I2C_MUX_CH_EMC2305, 0);
+	emc2305_init(I2C_EMC2305_ADDR1);
+	set_fan_speed(I2C_EMC2305_PWM, I2C_EMC2305_ADDR1);
+	emc2305_init(I2C_EMC2305_ADDR2);
+	set_fan_speed(I2C_EMC2305_PWM, I2C_EMC2305_ADDR2);
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT, 0);
+#endif
+
+	fsl_lsch3_early_init_f();
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_FIXUP
+int board_fix_fdt(void *fdt)
+{
+	char *reg_names, *reg_name;
+	int names_len, old_name_len, new_name_len, remaining_names_len;
+	struct str_map {
+		char *old_str;
+		char *new_str;
+	} reg_names_map[] = {
+		{ "ccsr", "dbi" },
+		{ "pf_ctrl", "ctrl" }
+	};
+	int off = -1, i = 0;
+
+	if (IS_SVR_REV(get_svr(), 1, 0))
+		return 0;
+
+	fdt_for_each_node_by_compatible(off, fdt, -1, "fsl,lx2160a-pcie") {
+		fdt_setprop(fdt, off, "compatible", "fsl,ls-pcie",
+			    strlen("fsl,ls-pcie") + 1);
+
+		reg_names = (char *)fdt_getprop(fdt, off, "reg-names",
+						&names_len);
+		if (!reg_names)
+			continue;
+
+		reg_name = reg_names;
+		remaining_names_len = names_len - (reg_name - reg_names);
+		i = 0;
+		while ((i < ARRAY_SIZE(reg_names_map)) && remaining_names_len) {
+			old_name_len = strlen(reg_names_map[i].old_str);
+			new_name_len = strlen(reg_names_map[i].new_str);
+			if (memcmp(reg_name, reg_names_map[i].old_str,
+				   old_name_len) == 0) {
+				/* first only leave required bytes for new_str
+				 * and copy rest of the string after it
+				 */
+				memcpy(reg_name + new_name_len,
+				       reg_name + old_name_len,
+				       remaining_names_len - old_name_len);
+				/* Now copy new_str */
+				memcpy(reg_name, reg_names_map[i].new_str,
+				       new_name_len);
+				names_len -= old_name_len;
+				names_len += new_name_len;
+				i++;
+			}
+
+			reg_name = memchr(reg_name, '\0', remaining_names_len);
+			if (!reg_name)
+				break;
+
+			reg_name += 1;
+
+			remaining_names_len = names_len -
+					      (reg_name - reg_names);
+		}
+
+		fdt_setprop(fdt, off, "reg-names", reg_names, names_len);
+	}
+
+	return 0;
+}
+#endif
+
+int esdhc_status_fixup(void *blob, const char *compat)
+{
+	/* Enable esdhc DT nodes */
+	do_fixup_by_compat(blob, compat, "status", "okay",
+			   sizeof("okay"), 1);
+
+	return 0;
+}
+
+#if defined(CONFIG_VID)
+int i2c_multiplexer_select_vid_channel(u8 channel)
+{
+	return select_i2c_ch_pca9547(channel, 0);
+}
+
+int init_func_vid(void)
+{
+	int set_vid;
+
+	if (IS_SVR_REV(get_svr(), 1, 0))
+		set_vid = adjust_vdd(800);
+	else
+		set_vid = adjust_vdd(0);
+
+	if (set_vid < 0)
+		printf("core voltage not adjusted\n");
+
+	return 0;
+}
+#endif
+
+int checkboard(void)
+{
+	enum boot_src src = get_boot_src();
+	char buf[64];
+	u8 sw;
+	int clock;
+	static const char *const freq[] = {"100", "", "", "161.13"};
+	u16 minor;
+
+	cpu_name(buf);
+
+	printf("Board: %s-BlueBox3, ", buf);
+
+	sw = QIXIS_READ(arch);
+	printf("Board version: %c, boot from ", (sw & 0xf) - 1 + 'A');
+
+	if (src == BOOT_SOURCE_SD_MMC) {
+		puts("SD\n");
+	} else if (src == BOOT_SOURCE_SD_MMC2) {
+		puts("eMMC\n");
+	} else {
+		sw = QIXIS_READ(brdcfg[0]);
+		sw = (sw >> QIXIS_XMAP_SHIFT) & QIXIS_XMAP_MASK;
+		switch (sw) {
+		case 0:
+			puts("FlexSPI DEV#0\n");
+			break;
+		case 1:
+			puts("FlexSPI DEV#1\n");
+			break;
+		default:
+			printf("invalid setting, xmap: %d\n", sw);
+			break;
+		}
+	}
+
+	printf("FPGA: v%d", (int)QIXIS_READ(scver));
+
+	minor = qixis_read_minor();
+	if (minor)
+		printf(".%d", minor);
+
+	/* the timestamp string contains "\n" at the end */
+	printf(" built on %s", qixis_read_time(buf));
+
+	puts("SERDES1 Reference : ");
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = sw >> 6 & SERDES_CLOCK_MASK;
+	printf("Clock1 = %sMHz ", freq[clock]);
+	clock = sw >> 4 & SERDES_CLOCK_MASK;
+	printf("Clock2 = %sMHz", freq[clock]);
+
+	puts("\nSERDES2 Reference : ");
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = sw >> 2 & SERDES_CLOCK_MASK;
+	printf("Clock1 = %sMHz ", freq[clock]);
+	clock = sw & SERDES_CLOCK_MASK;
+	printf("Clock2 = %sMHz", freq[clock]);
+
+	puts("\nSERDES3 Reference : ");
+	sw = QIXIS_READ(brdcfg[3]);
+	clock = sw >> 6 & SERDES_CLOCK_MASK;
+	printf("Clock1 = %sMHz ", freq[clock]);
+	clock = sw >> 4 & SERDES_CLOCK_MASK;
+	printf("Clock2 = %sMHz\n", freq[clock]);
+
+	return 0;
+}
+
+int config_board_mux(void)
+{
+	u8 brdcfg;
+
+	brdcfg = QIXIS_READ(brdcfg[4]);
+	/* The BRDCFG4 register controls general board configuration.
+	 *|-------------------------------------------|
+	 *|Field  | Function                          |
+	 *|-------------------------------------------|
+	 *|5      | CAN I/O Enable (net CFG_CAN_EN_B):|
+	 *|CAN_EN | 0= CAN transceivers are disabled. |
+	 *|       | 1= CAN transceivers are enabled.  |
+	 *|-------------------------------------------|
+	 */
+	brdcfg |= BIT_MASK(5);
+	QIXIS_WRITE(brdcfg[4], brdcfg);
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	return 100000000;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	return 100000000;
+}
+
+int board_init(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	struct ccsr_gur __iomem *dcsr = (void *)(DCFG_DCSR_BASE);
+	u32 rcwsr28;
+	u32 srds_s1;
+
+#if defined(CONFIG_FSL_MC_ENET)
+	u32 __iomem *irq_ccsr = (u32 __iomem *)ISC_BASE;
+#endif
+#ifdef CONFIG_ENV_IS_NOWHERE
+	gd->env_addr = (ulong)&default_environment[0];
+#endif
+
+	/*
+	 * Ensure the PCIe slot 6 on the T6 riser is preconfigured
+	 * properly for the inserted card. This is benign and silent
+	 * if the riser is not inserted as it carefully probes the I2C.
+	 */
+	configure_t6slot6();
+
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT, 0);
+
+	/* bluebox3 board uses a custom serdes protocol encoding */
+	rcwsr28 = in_le32(&gur->rcwsr[28]);
+	srds_s1 = rcwsr28 & FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+
+	/* SerDes1 protocol 11 becomes 31 */
+	if (srds_s1 == 11) {
+		rcwsr28 &= ~FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK;
+		rcwsr28 |= 31 << FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+		out_le32(&dcsr->rcwsr[28], rcwsr28);
+	}
+
+#if defined(CONFIG_FSL_MC_ENET)
+	/* invert AQR113 IRQ pins polarity */
+	out_le32(irq_ccsr + IRQCR_OFFSET / 4, AQR113_IRQ_MASK);
+#endif
+
+#ifdef CONFIG_FSL_CAAM
+	sec_init();
+#endif
+
+#if !defined(CONFIG_SYS_EARLY_PCI_INIT) && defined(CONFIG_DM_ETH)
+	pci_init();
+#endif
+	return 0;
+}
+
+void detail_board_ddr_info(void)
+{
+	int i;
+	u64 ddr_size = 0;
+
+	puts("\nDDR    ");
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		ddr_size += gd->bd->bi_dram[i].size;
+	print_size(ddr_size, "");
+	print_ddr_info(0);
+}
+
+#ifdef CONFIG_MISC_INIT_R
+int misc_init_r(void)
+{
+	config_board_mux();
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_VID
+u16 soc_get_fuse_vid(int vid_index)
+{
+	static const u16 vdd[32] = {
+		8250,
+		7875,
+		7750,
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		8000,
+		8125,
+		8250,
+		0,      /* reserved */
+		8500,
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+		0,      /* reserved */
+	};
+
+	return vdd[vid_index];
+};
+#endif
+
+#ifdef CONFIG_FSL_MC_ENET
+extern int fdt_fixup_board_phy(void *fdt);
+
+void fdt_fixup_board_enet(void *fdt)
+{
+	int offset;
+
+	offset = fdt_path_offset(fdt, "/soc/fsl-mc");
+
+	if (offset < 0)
+		offset = fdt_path_offset(fdt, "/fsl-mc");
+
+	if (offset < 0) {
+		printf("%s: fsl-mc node not found in device tree (error %d)\n",
+		       __func__, offset);
+		return;
+	}
+
+	if (get_mc_boot_status() == 0 &&
+	    (is_lazy_dpl_addr_valid() || get_dpl_apply_status() == 0)) {
+		fdt_status_okay(fdt, offset);
+#ifndef CONFIG_DM_ETH
+		fdt_fixup_board_phy(fdt);
+#endif
+	} else {
+		fdt_status_fail(fdt, offset);
+	}
+}
+
+void board_quiesce_devices(void)
+{
+	fsl_mc_ldpaa_exit(gd->bd);
+}
+#endif
+
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	int i;
+	u16 mc_memory_bank = 0;
+
+	u64 *base;
+	u64 *size;
+	u64 mc_memory_base = 0;
+	u64 mc_memory_size = 0;
+	u16 total_memory_banks;
+	int err;
+
+	err = fdt_increase_size(blob, 512);
+	if (err) {
+		printf("%s fdt_increase_size: err=%s\n", __func__,
+		       fdt_strerror(err));
+		return err;
+	}
+
+	ft_cpu_setup(blob, bd);
+
+	fdt_fixup_mc_ddr(&mc_memory_base, &mc_memory_size);
+
+	if (mc_memory_base != 0)
+		mc_memory_bank++;
+
+	total_memory_banks = CONFIG_NR_DRAM_BANKS + mc_memory_bank;
+
+	base = calloc(total_memory_banks, sizeof(u64));
+	size = calloc(total_memory_banks, sizeof(u64));
+
+	/* fixup DT for the three GPP DDR banks */
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		base[i] = gd->bd->bi_dram[i].start;
+		size[i] = gd->bd->bi_dram[i].size;
+	}
+
+#ifdef CONFIG_RESV_RAM
+	/* reduce size if reserved memory is within this bank */
+	if (gd->arch.resv_ram >= base[0] &&
+	    gd->arch.resv_ram < base[0] + size[0])
+		size[0] = gd->arch.resv_ram - base[0];
+	else if (gd->arch.resv_ram >= base[1] &&
+		 gd->arch.resv_ram < base[1] + size[1])
+		size[1] = gd->arch.resv_ram - base[1];
+	else if (gd->arch.resv_ram >= base[2] &&
+		 gd->arch.resv_ram < base[2] + size[2])
+		size[2] = gd->arch.resv_ram - base[2];
+#endif
+
+	if (mc_memory_base != 0) {
+		for (i = 0; i <= total_memory_banks; i++) {
+			if (base[i] == 0 && size[i] == 0) {
+				base[i] = mc_memory_base;
+				size[i] = mc_memory_size;
+				break;
+			}
+		}
+	}
+
+	fdt_fixup_memory_banks(blob, base, size, total_memory_banks);
+
+#ifdef CONFIG_USB_HOST
+	fsl_fdt_fixup_dr_usb(blob, bd);
+#endif
+
+#ifdef CONFIG_FSL_MC_ENET
+	fdt_fsl_mc_fixup_iommu_map_entry(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+	fdt_fixup_icid(blob);
+
+	return 0;
+}
+#endif
+
+void qixis_dump_switch(void)
+{
+	int i, nr_of_cfgsw;
+
+	QIXIS_WRITE(cms[0], 0x00);
+	nr_of_cfgsw = QIXIS_READ(cms[1]);
+
+	puts("DIP switch settings dump:\n");
+	for (i = 1; i <= nr_of_cfgsw; i++) {
+		QIXIS_WRITE(cms[0], i);
+		printf("SW%d = (0x%02x)\n", i, QIXIS_READ(cms[1]));
+	}
+}
diff --git a/configs/lx2160abluebox3_tfa_SECURE_BOOT_defconfig b/configs/lx2160abluebox3_tfa_SECURE_BOOT_defconfig
new file mode 100644
index 0000000000..a73d0817f0
--- /dev/null
+++ b/configs/lx2160abluebox3_tfa_SECURE_BOOT_defconfig
@@ -0,0 +1,119 @@
+CONFIG_ARM=y
+CONFIG_SKIP_LOWLEVEL_INIT=y
+CONFIG_GIC_V3_ITS=y
+CONFIG_TARGET_LX2160ABLUEBOX3=y
+CONFIG_TFABOOT=y
+CONFIG_SYS_TEXT_BASE=0x82000000
+CONFIG_SYS_MALLOC_LEN=0x202000
+CONFIG_SYS_MALLOC_F_LEN=0x6000
+CONFIG_NR_DRAM_BANKS=3
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_OFFSET=0x500000
+CONFIG_ENV_SECT_SIZE=0x20000
+CONFIG_NXP_ESBC=y
+CONFIG_RSA=y
+CONFIG_SPL_RSA=y
+CONFIG_RSA_SOFTWARE_EXP=y
+CONFIG_DM_GPIO=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-lx2160a-bluebox3"
+CONFIG_FSL_USE_PCA9547_MUX=y
+CONFIG_VID=y
+CONFIG_SPL_VID=y
+CONFIG_VID_FLS_ENV="lx2160abluebox3_vdd_mv"
+CONFIG_VOL_MONITOR_LTC7132_READ=y
+CONFIG_VOL_MONITOR_LTC7132_SET=y
+CONFIG_EMC2305=y
+CONFIG_FSPI_AHB_EN_4BYTE=y
+CONFIG_ARMV8_SEC_FIRMWARE_SUPPORT=y
+CONFIG_SEC_FIRMWARE_ARMV8_PSCI=y
+CONFIG_AHCI=y
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_REMAKE_ELF=y
+CONFIG_MP=y
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_STDOUT_VIA_ALIAS=y
+CONFIG_DYNAMIC_DDR_CLK_FREQ=y
+CONFIG_DYNAMIC_SYS_CLK_FREQ=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200 root=/dev/ram0 earlycon=pl011,mmio32,0x21c0000 ramdisk_size=0x2000000 default_hugepagesz=1024m hugepagesz=1024m hugepages=2 pci=pcie_bus_perf"
+CONFIG_MISC_INIT_R=y
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_EEPROM=y
+CONFIG_SYS_EEPROM_PAGE_WRITE_BITS=3
+CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS=5
+CONFIG_CMD_DM=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_OPTEE_RPMB=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_SETEXPR=y
+CONFIG_CMD_WDT=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_DATE=y
+CONFIG_OF_CONTROL=y
+CONFIG_ENV_OVERWRITE=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_ADDR=0x20500000
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_FSL_CAAM=y
+CONFIG_DDR_ECC=y
+CONFIG_ECC_INIT_VIA_DDRCONTROLLER=y
+CONFIG_MPC8XXX_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x57
+CONFIG_SUPPORT_EMMC_RPMB=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_DM_MMC=y
+CONFIG_FSL_ESDHC=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_MT35XU=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_PHYLIB=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_PHY_ATHEROS=y
+CONFIG_DM_ETH=y
+CONFIG_DM_MDIO=y
+CONFIG_E1000=y
+CONFIG_MII=y
+CONFIG_FSL_LS_MDIO=y
+CONFIG_NVME_PCI=y
+CONFIG_PCI=y
+CONFIG_PCIE_LAYERSCAPE_RC=y
+CONFIG_PCIE_LAYERSCAPE_EP=y
+CONFIG_PCIE_LAYERSCAPE_GEN4=y
+CONFIG_PCI_IOMMU_EXTRA_MAPPINGS=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_PCF2127=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_NXP_FSPI=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_WDT=y
+CONFIG_WDT_SBSA=y
+CONFIG_USB_STORAGE=y
+CONFIG_EFI_LOADER_BOUNCE_BUFFER=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_CMD_NVME=y
+CONFIG_NVME=y
diff --git a/configs/lx2160abluebox3_tfa_defconfig b/configs/lx2160abluebox3_tfa_defconfig
new file mode 100644
index 0000000000..744fe11e4d
--- /dev/null
+++ b/configs/lx2160abluebox3_tfa_defconfig
@@ -0,0 +1,116 @@
+CONFIG_ARM=y
+CONFIG_SKIP_LOWLEVEL_INIT=y
+CONFIG_GIC_V3_ITS=y
+CONFIG_TARGET_LX2160ABLUEBOX3=y
+CONFIG_TFABOOT=y
+CONFIG_SYS_TEXT_BASE=0x82000000
+CONFIG_SYS_MALLOC_LEN=0x202000
+CONFIG_SYS_MALLOC_F_LEN=0x6000
+CONFIG_NR_DRAM_BANKS=3
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_OFFSET=0x500000
+CONFIG_ENV_SECT_SIZE=0x20000
+CONFIG_DM_GPIO=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-lx2160a-bluebox3"
+CONFIG_FSL_USE_PCA9547_MUX=y
+CONFIG_VID=y
+CONFIG_SPL_VID=y
+CONFIG_VID_FLS_ENV="lx2160abluebox3_vdd_mv"
+CONFIG_VOL_MONITOR_LTC7132_READ=y
+CONFIG_VOL_MONITOR_LTC7132_SET=y
+CONFIG_EMC2305=y
+CONFIG_FSPI_AHB_EN_4BYTE=y
+CONFIG_ARMV8_SEC_FIRMWARE_SUPPORT=y
+CONFIG_SEC_FIRMWARE_ARMV8_PSCI=y
+CONFIG_AHCI=y
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_REMAKE_ELF=y
+CONFIG_MP=y
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_STDOUT_VIA_ALIAS=y
+CONFIG_DYNAMIC_DDR_CLK_FREQ=y
+CONFIG_DYNAMIC_SYS_CLK_FREQ=y
+CONFIG_BOOTDELAY=10
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200 root=/dev/ram0 earlycon=pl011,mmio32,0x21c0000 ramdisk_size=0x2000000 default_hugepagesz=1024m hugepagesz=1024m hugepages=2 pci=pcie_bus_perf"
+CONFIG_MISC_INIT_R=y
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_EEPROM=y
+CONFIG_SYS_EEPROM_PAGE_WRITE_BITS=3
+CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS=5
+CONFIG_CMD_DM=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_OPTEE_RPMB=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_SETEXPR=y
+CONFIG_CMD_WDT=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_DATE=y
+CONFIG_OF_CONTROL=y
+CONFIG_ENV_OVERWRITE=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_ADDR=0x20500000
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_FSL_CAAM=y
+CONFIG_DDR_ECC=y
+CONFIG_ECC_INIT_VIA_DDRCONTROLLER=y
+CONFIG_MPC8XXX_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x57
+CONFIG_SUPPORT_EMMC_RPMB=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_DM_MMC=y
+CONFIG_FSL_ESDHC=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_MT35XU=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_PHYLIB=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_PHY_ATHEROS=y
+CONFIG_DM_ETH=y
+CONFIG_DM_MDIO=y
+CONFIG_E1000=y
+CONFIG_MII=y
+CONFIG_FSL_LS_MDIO=y
+CONFIG_NVME_PCI=y
+CONFIG_PCI=y
+CONFIG_PCIE_LAYERSCAPE_RC=y
+CONFIG_PCIE_LAYERSCAPE_EP=y
+CONFIG_PCIE_LAYERSCAPE_GEN4=y
+CONFIG_PCI_IOMMU_EXTRA_MAPPINGS=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_PCF2127=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_NXP_FSPI=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_WDT=y
+CONFIG_WDT_SBSA=y
+CONFIG_USB_STORAGE=y
+CONFIG_EFI_LOADER_BOUNCE_BUFFER=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_CMD_NVME=y
+CONFIG_NVME=y
diff --git a/include/configs/lx2160abluebox3.h b/include/configs/lx2160abluebox3.h
new file mode 100644
index 0000000000..cf41c52478
--- /dev/null
+++ b/include/configs/lx2160abluebox3.h
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2020-2021 NXP
+ */
+
+#ifndef __LX2_BLUEBOX3_H
+#define __LX2_BLUEBOX3_H
+
+#include "lx2160a_common.h"
+
+/* Qixis */
+#define QIXIS_XMAP_MASK			0x01
+#define QIXIS_XMAP_SHIFT		5
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		QIXIS_XMAP_MASK << QIXIS_XMAP_SHIFT
+#define QIXIS_LBMAP_QSPI		0x00
+#define QIXIS_RCW_SRC_QSPI		0xff
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SD
+#define QIXIS_LBMAP_EMMC
+#define QIXIS_RCW_SRC_SD           0x08
+#define QIXIS_RCW_SRC_EMMC         0x09
+#define NON_EXTENDED_DUTCFG
+
+/* T6 riser I2C extension for slot 6 support */
+#define I2C_PCIE_BUS_NUM		2	/* PCIe on I2C6 */
+#define I2C_PCIE_MUX_PCA9846_ADDR_PRI	0x77	/* On main board */
+#define I2C_PCIE_MUX_CH_PCIE_MB2	0x4
+#define I2C_T6_PCA9546_ADDR		0x71	/* On T6 */
+#define I2C_T6_MUX_CH_SLOT6CTRL		0x8
+#define I2C_T6_PCAL6408_ADDR		0x20
+#define I2C_T6_PCAL6408_INPUT_PORT	0
+#define I2C_T6_PCAL6408_PRESENCE_DETECT_MASK	0x0f
+#define I2C_T6_PTN3944_BASE_ADDR	0x30
+
+#define PTN3944_LINK_CTRL_STATUS	0x06
+#define PTN3944_LCS_CHANNEL_MASK	0x0c
+#define PTN3944_LCS_0CHANNELS		0x00
+#define PTN3944_LCS_1CHANNELS		0x04
+#define PTN3944_LCS_2CHANNELS		0x08
+#define PTN3944_LCS_4CHANNELS		0x0c
+
+/* VID */
+
+#define I2C_MUX_CH_VOL_MONITOR		0xA
+/* Voltage monitor LTC7132 on channel 2*/
+#define I2C_VOL_MONITOR_ADDR		0x63
+
+/* The lowest and highest voltage allowed*/
+#define VDD_MV_MIN			775
+#define VDD_MV_MAX			855
+
+/* Channel to be used with LTC7132 */
+#define PWM_CHANNEL0                    0xff
+
+/* RTC */
+#define CONFIG_SYS_RTC_BUS_NUM		0   /* Channel 4 I2C bus 0*/
+#define I2C_MUX_CH_RTC			0xC /* Channel 4*/
+
+/* MAC/PHY configuration */
+#if defined(CONFIG_FSL_MC_ENET)
+#define CONFIG_ETHPRIME		"DPMAC17@rgmii-id"
+
+#define AQR113_PHY_ADDR1	0x08
+#define AQR113_PHY_ADDR2	0x00
+#define AQR113_PHY_ADDR3	0x08
+#define AQR113_PHY_ADDR4	0x00
+#define AQR113_IRQ_MASK		0x3C
+
+#define RGMII_PHY_ADDR1		0x01
+#define RGMII_PHY_ADDR2		0x02
+
+#endif
+
+/* EMC2305 */
+#define I2C_MUX_CH_EMC2305	0x9
+#define I2C_EMC2305_ADDR1	0x4C
+#define I2C_EMC2305_ADDR2	0x4D
+#define I2C_EMC2305_CMD		0x40
+#define I2C_EMC2305_PWM		0x80
+
+/* EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	           0
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	    1
+
+/* SerDes */
+#define SERDES_CLOCK_MASK                      0x3
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	EXTRA_ENV_SETTINGS			\
+	"boot_scripts=lx2160bluebox3_boot.scr\0"	\
+	"boot_script_hdr=hdr_lx2160bluebox3_bs.out\0"	\
+	"BOARD=lx2160abluebox3\0"			\
+	"xspi_bootcmd=echo Trying load from flexspi..;"		\
+		"sf probe 0:0 && sf read $load_addr "		\
+		"$kernel_start $kernel_size ; env exists secureboot &&"	\
+		"sf read $kernelheader_addr_r $kernelheader_start "	\
+		"$kernelheader_size && esbc_validate ${kernelheader_addr_r}; "\
+		" bootm $load_addr#$BOARD\0"			\
+	"sd_bootcmd=echo Trying load from sd card..;"		\
+		"mmcinfo; mmc read $load_addr "			\
+		"$kernel_addr_sd $kernel_size_sd ;"		\
+		"env exists secureboot && mmc read $kernelheader_addr_r "\
+		"$kernelhdr_addr_sd $kernelhdr_size_sd "	\
+		" && esbc_validate ${kernelheader_addr_r};"	\
+		"bootm $load_addr#$BOARD\0"			\
+	"sd2_bootcmd=echo Trying load from emmc card..;"	\
+		"mmc dev 1; mmcinfo; mmc read $load_addr "	\
+		"$kernel_addr_sd $kernel_size_sd ;"		\
+		"env exists secureboot && mmc read $kernelheader_addr_r "\
+		"$kernelhdr_addr_sd $kernelhdr_size_sd "	\
+		" && esbc_validate ${kernelheader_addr_r};"	\
+		"bootm $load_addr#$BOARD\0"
+
+#include <asm/fsl_secure_boot.h>
+
+#endif /* __LX2_BLUEBOX3_H */
-- 
2.34.1

